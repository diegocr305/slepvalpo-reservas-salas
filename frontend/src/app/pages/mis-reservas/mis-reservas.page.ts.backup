import { Component, OnInit, OnDestroy, ChangeDetectorRef } from '@angular/core';
import { ViewWillEnter } from '@ionic/angular';
import { Subscription } from 'rxjs';
import { take } from 'rxjs/operators';
import { CommonModule, DatePipe } from '@angular/common';
import { IonContent, IonHeader, IonTitle, IonToolbar, IonCard, IonCardContent, IonCardHeader, IonCardTitle, IonCardSubtitle, IonButton, IonIcon, IonChip, IonLabel, IonFab, IonFabButton, IonSpinner, IonRippleEffect, AlertController, ToastController } from '@ionic/angular/standalone';
import { addIcons } from 'ionicons';import { locationOutline, businessOutline, calendarOutline, timeOutline, documentTextOutline, closeCircleOutline, checkmarkCircle, closeCircle, warning } from 'ionicons/icons';
import { RouterLink } from '@angular/router';
import { SupabaseService } from '../../services/supabase.service';
import { AuthService } from '../../services/auth.service';
import { EmailService } from '../../services/email.service';
import { ReservaCompleta } from '../../models/reserva.model';

@Component({
  selector: 'app-mis-reservas',
  templateUrl: './mis-reservas.page.html',
  styleUrls: ['./mis-reservas.page.scss'],
  standalone: true,
  imports: [CommonModule, DatePipe, RouterLink, IonContent, IonHeader, IonTitle, IonToolbar, IonCard, IonCardContent, IonCardHeader, IonCardTitle, IonCardSubtitle, IonButton, IonIcon, IonChip, IonLabel, IonFab, IonFabButton, IonSpinner, IonRippleEffect]
})
export class MisReservasPage implements OnInit, OnDestroy, ViewWillEnter {
  reservas: ReservaCompleta[] = [];
  cargando = false;
  primeraCarga = true;
  private userSubscription?: Subscription;

  constructor(
    private supabase: SupabaseService,
    private auth: AuthService,
    private email: EmailService,
    private alertController: AlertController,
    private toastController: ToastController,
    private cdr: ChangeDetectorRef
  ) {
    addIcons({ locationOutline, businessOutline, calendarOutline, timeOutline, documentTextOutline, closeCircleOutline, checkmarkCircle, closeCircle, warning });
  }

  async ngOnInit() {
    console.log('ðŸš€ Inicializando pÃ¡gina Mis Reservas');
  }

  ionViewWillEnter() {
    console.log('ðŸ”„ Entrando a la vista Mis Reservas');
    this.cargando = true;
    this.primeraCarga = true;
    this.cdr.detectChanges();
    
    this.cargarReservasConEspera();
  }

  private async cargarReservasConEspera() {
    let intentos = 0;
    const maxIntentos = 10;
    
    const verificarUsuario = async () => {
      const usuario = this.auth.user;
      
      if (usuario) {
        console.log('âœ… Usuario disponible, cargando reservas...');
        await this.cargarReservas();
      } else if (intentos < maxIntentos) {
        intentos++;
        console.log(`â³ Intento ${intentos}/${maxIntentos} - Esperando usuario...`);
        setTimeout(verificarUsuario, 200);
      } else {
        console.log('âŒ No se pudo obtener el usuario despuÃ©s de varios intentos');
        this.cargando = false;
        this.primeraCarga = false;
        this.cdr.detectChanges();
      }
    };
    
    verificarUsuario();
  }

  ngOnDestroy() {
    if (this.userSubscription) {
      this.userSubscription.unsubscribe();
    }
  }

  async cargarReservas(event?: any) {
    console.log('ðŸ”„ Iniciando carga de reservas...');
    this.cargando = true;
    
    try {
      const usuario = this.auth.user;
      console.log('ðŸ‘¤ Usuario actual:', usuario);
      
      if (!usuario) {
        console.log('âŒ No hay usuario logueado');
        return;
      }

      console.log('ðŸ” Buscando reservas para usuario ID:', usuario.id);
      
      const { data, error } = await this.supabase.supabase
        .from('reservas')
        .select(`
          id,
          fecha,
          hora_inicio,
          hora_fin,
          proposito,
          estado,
          salas!inner(
            nombre,
            edificios!inner(
              nombre
            )
          )
        `)
        .eq('usuario_id', usuario.id)
        .order('fecha', { ascending: false })
        .limit(50);
      
      console.log('ðŸ“Š Respuesta de la base de datos:', { data, error });
      
      if (error) throw error;
      
      this.reservas = (data || []).map((reserva: any) => ({
        ...reserva,
        sala_nombre: reserva.salas?.nombre || 'Sala no encontrada',
        edificio_nombre: reserva.salas?.edificios?.nombre || 'Edificio no encontrado'
      })).sort((a, b) => 
        new Date(b.fecha + ' ' + b.hora_inicio).getTime() - 
        new Date(a.fecha + ' ' + a.hora_inicio).getTime()
      );
      
      // Forzar detecciÃ³n de cambios
      this.cdr.detectChanges();
      
    } catch (error) {
      console.error('âŒ Error cargando reservas:', error);
      this.mostrarError('Error cargando las reservas');
    } finally {
      this.cargando = false;
      this.primeraCarga = false;
      this.cdr.detectChanges();
      if (event) event.target.complete();
      console.log('ðŸ Carga de reservas finalizada');
    }
  }

  async cancelarReserva(reserva: ReservaCompleta) {
    const alert = await this.alertController.create({
      header: 'Cancelar Reserva',
      message: `Â¿EstÃ¡s seguro de cancelar la reserva del ${reserva.fecha} en ${reserva.sala_nombre}?`,
      buttons: [
        { text: 'No', role: 'cancel' },
        { 
          text: 'SÃ­, Cancelar', 
          handler: () => this.confirmarCancelacion(reserva)
        }
      ]
    });
    await alert.present();
  }

  private async confirmarCancelacion(reserva: ReservaCompleta) {
    try {
      // Eliminar la reserva completamente en lugar de solo cambiar el estado
      const { error } = await this.supabase.delete('reservas', reserva.id);
      
      if (error) throw error;
      
      // Actualizar la lista localmente sin recargar desde la BD
      this.reservas = this.reservas.filter(r => r.id !== reserva.id);
      
      await this.email.enviarNotificacionReservaCancelada(reserva);
      this.mostrarExito('Reserva cancelada exitosamente');
      
    } catch (error) {
      console.error('Error cancelando reserva:', error);
      this.mostrarError('Error al cancelar la reserva');
    }
  }

  getColorEstado(estado: string): string {
    switch (estado) {
      case 'confirmada': return 'success';
      case 'cancelada': return 'medium';
      case 'no_show': return 'danger';
      default: return 'primary';
    }
  }

  getIconoEstado(estado: string): string {
    switch (estado) {
      case 'confirmada': return 'checkmark-circle';
      case 'cancelada': return 'close-circle';
      case 'no_show': return 'warning';
      default: return 'time';
    }
  }

  esReservaPasada(reserva: ReservaCompleta): boolean {
    const fechaReserva = new Date(reserva.fecha + ' ' + reserva.hora_fin);
    return fechaReserva < new Date();
  }

  puedeEditar(reserva: ReservaCompleta): boolean {
    return reserva.estado === 'confirmada' && !this.esReservaPasada(reserva);
  }

  private async mostrarError(mensaje: string) {
    const toast = await this.toastController.create({
      message: mensaje,
      duration: 3000,
      color: 'danger',
      position: 'top'
    });
    toast.present();
  }

  private async mostrarExito(mensaje: string) {
    const toast = await this.toastController.create({
      message: mensaje,
      duration: 3000,
      color: 'success',
      position: 'top'
    });
    toast.present();
  }
}